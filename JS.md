#### 현재 웹 애플리케이션 구현 
>SPA (Single Page Application) 방식
#### JS 사용의 목적
>DOM(HTML, CSS)를 JS로 제어 
#### 비동기 통신 방식 
```
예를 들어보자. 
클릭버튼!
클릭이 언제 발생할지 알 수 없다! 
클릭이 발생하면 수행할 행위를 정해놓는다.(이 경우에는 eventlistner가 동작하면서 클릭 발생을 모니터링)
```
##### ECMA Script 버전 ES3/5/6
##### REACT는	LIBRARY에 가까움
##### ANGULAR :	FRAMEWORK는 애플리케이션 전체를 아우름
	
#### 초기 JS의 용도 
```
ID/PW 입력 여부 확인과 같은 행위를 하기 위해서 비전문가들도 쉽게 JS를 활용 가능하도록 만들어졌다. 
일반 애플리케이션은 OS에서 동작하도록 만들었으나 (설치 과정이 수반) 웹 애플리케이션은 그런 과정을 생략할 수 있다. 
그러면 웹 애플리케이션은 어떻게 동작시킬 것인가? 웹 브라우저에서 애플리케이션을 실행/제어하자 → JS 필요
초창기에는 PLAIN JS로 코딩하기가 어려웠음 → JQUERY 등장 → 그런데 JQUERY가 SPA에는 적합하지 않았음 
(JQUERY는 HTML에 의존적이기 때문에 사용을 지양하게 되었음) → ANGULAR, REACT, Vue.js의 사용이 대두
그러나, JS는 애플리케이션용 언어가 아니기 때문에 태생적 한계가 있다!
```
#### JS는 프로토타입 기반 객체지향 언어	
>클래스 vs 프로토타입    
#### Object 프로그래밍 하는 대상들을 각각 object로 인식 
>객체는 데이터와 행위를 포함한다 - 표현식으로 객체를 바로 생성 가능

#### 프로토타입의 정의?
>To be explained
	
#### JS	HTML, CSS를 JS로 동적으로 제어

#### 웹 브라우저의 동작 원리 (brief)
```파서``` : 텍스트를 파싱해서(txt-> byte code) 메모리에 저장 (line by line)  
**스크립트의 위치**는 *head*안이 아니고 **body**를 닫기 전에 위치 한다.  
```DOM(HTML요소)```를 제어하기 위해서는 바디 태그 맨 마지막에 있어야 한다.

#### 모듈화 미 지원	
```파일을 분리할 수 없음```  
여러 JS 파일 있어도 한개 파일만 동작. ES6에서 파일을 쪼개는 기능을 지원하나 현재 브라우저에서는 미지원.  
따라서 ```webpack```을 사용하여 이를 보완하고자 한다.
#### 브라우저 동작 원리	
DOM/CSSOM/syntax Tree는 메모리에 저장된다. HTML 1.1에서는 파일을 각각 요청해서 받음 (html, css, script 각각)  
**2.0은 다중 요청**이 가능하다고 한다.
#### 값 = literal	
숫자, 문자열(한개 이상의 문자 모두), boolean, undefined, null,symbol // 이상은 ```기본 자료형```  
_(**변수에 할당될** 바이트 수가 정해져 있다)_  
메모리 확보하는 방법이 다른 한 가지 // ```객체형```_(변수에 할당될 바이트수가 유동적)_  

#### Statement의 예를 보자
>var foo = 10;  
```선언문이자 할당문```  
var foo;  
```선언만 하고 할당 하지 않았다.``` 이러한 경우 **undefined**를 기본으로 갖게 됨
symbol은 ES6에서 추가됨  
표현식 정의  
```x + y 와 같이 특정 값을 갖게 될 수 있는 형식```

#### 코드블록으로 구문 그룹화
```
중괄호로 지정한 범위 구문은 세미콜론으로 닫는다. (optional)  
필요한 구문을 그룹화하여 추후 재사용 하도록 하자.  
```
#### scope	
변수의 범위 (유효범위-코드블럭)
#### control flow	
```
JS코딩에 익숙해지면 if/for는 지양해야 한다. 이유는 코드를 읽기가 어렵기 때문. 
그래서 고차함수를 사용함 (JS는 함수형 언어)
현재는 코드의 가독성을 높이는 것에 초점을 맞춘다. 코드의 효율성보다도 중요 
그래서 변수/함수 생성시 이름 중요(역할/용도 등의 힌트를 줄 수 있어야 한다.)
```
#### Expression(표현식)	
궁극적으로 하나의 값을 만드는 것  
#### 동적 typing  
var foo 에는 모든 형태의 변수가 다 들어올 수 있다  그래서 type을 지정하기 위해서 typescript 사용  
Var foo : string; (정적 typing)
# 변수 	
위치를 기억하는 저장소  
숫자표현은 8바이트가 할당된다.
메모리 참조 : 변수가 어디에 저장되었는지 찾자   
call by value 방식  
**STACK** : 정해진 크기의 메모리 할당 (기본자료형 할당되는 공간)  
**HEAP** : 유동적 크기의 메모리 할당 (객체형 할당)

*cf.* 문자열 1개는 2byte



	
```프로그래밍을 이해하기 위한``` _KEYWORDS  
>변수, 참조, 연산자, (데이터)흐름제어, 함수, 구문의 집합, 자료의 구조화

# 변수 (다시 한 번)
	변수는 주소를 식별할 수 있다.
	변수 할당 시 데이터의 크기 Var num(동적 타이핑) : 메모리의 일정 구역 확보 → undefined(변수선언 시 초기화 : 불필요한 더미값을 클리어 한다) → 값 할당 → 재할당할 경우 주소 변경되어 남게 된 기존 값은 불필요하기 때문에 garbage collection의 대상이 됨. (아무도 참조하지 않는 값) / garbage collection이 발생하는 시기는 알 수 없음
*cf.* 메모리의 이해  
#### 타입 추론
데이터형의 인지 : 값이 할당되는 과정에서 자동으로 변수의 자료형을 결정  
```기본자료형 vs 객체형```  
기본자료형 (primitive)은 변경불가능(immutable)한 값 (generally important in programming language)  
Pass by value
1. **boolean**	
2. **null** : 값이 없음을 명시하는 것 (참조 정보 제거 → garbage collection 대상이 됨) 굳이 null 변수 선언/할당할 필요는 없음
3. **undefined** : 변수 선언만 했을 때, 존재하지 않는 프로퍼티를 참조 시 undefined
4. **number** : JS에서는 숫자는 모두 실수 (*Infinity* : 2의 53승-1을 벗어나면 무한대 // *NaN* : 숫자를 문자로 나누는 등)
5. **string** : 여타 프로그래밍 언어에서는 string은 기본자료형이 아님
	
#### 객체형  
기본자료형과 반대되는 특징들이 많다. 크기가 정해지지 않는다!  
기본자료형은 stack에, 가변적인 객체형은 heap영역에서 관리됨   
`Mutable` 하다!  
	pass by reference :  
	**추상화** : 필요한 프로퍼티만 선언해서 객체를 표현한다. (프로퍼티와 행위로 객체를 구성)  
	**상속** : 다른 객체의 속성을 상속 받고 다른 속성도 사용할 수 있음  

**전역 변수** : 애플리케이션이 종료되지 않는 이상 계속 메모리 차지 (x=1처럼 var 키워드 생략 허용)  
**지역 변수** :	함수 내에게 선언된 변수  
**동적 타이핑** : 데이터 타입을 미리 선언하지 않는다. (값이 할당될 때 변수의 타입이 추론 될 것이다.)  
**정적 타이핑** : 미리 선언한다. (int n, char str 등등)
	
var 키워드로 선언된 변수의 문제점	다른 언어는 모든 코드 블럭이 유효범위(스코프) JS는 함수 범위만 유효
	대부분의 문제는 전역 변수로 인해 발생한다. 
연산자	
	숫자+문자할때는 자료형을 명시적으로 바꿔서 작업
'==’	사용 금지
html	자료를 받을 때는 모두 string (우리가 숫자를 입력하더라도..)
삼항연산자	활용도 높음  Condition ? ‘true’ : ‘false’;
	
var INPUT_ID_MIN_LEN = 5;	상수! (재할당하면 안됨 그러나 var는 강제할 방법 없음, 길고 자세한 대문자 변수명으로 의미만 부여하는 것임)
id.length	기본자료형(string)이었는데 이렇게 선언되면서 id가 객체로 취급된다
	
10+’10’ 10+10	OR조건으로 문자가 있으면 문자열 연결 연산자 AND조건으로 숫자가 있어야 산술 연산자
논리연산자	
var n3 = !'Cat';	 // false (문자열을 암묵적으로 형변환했다 -true)
	
단축평가	var foo = 'Cat' || 'Dog' (형변환 된 것이 넘어가는게 아니다!!!)
	Truthy / falsy
방어 코드 (미입력으로 인한 오류발생 방지)	function foo (str) {   str = str || '';   // do somethig with str   console.log(str.length); }  foo();     // 0 foo('hi'); // 2
빈 객체	truthy 밸류
!!	
자료형의 인식 	자료형의 인식을 통해서 오류 최소화, 인식이 안되면 강제로 형 변환 해야 함.
control flow	
for 문 중요	for문 대신 고차함수를 실무에서는 더 많이 사용함
블럭 구문	코드 블럭 (구문들의 집합체)   그룹화해서 재사용하려고 만든다
객체 만드는 3가지방법	객체리터럴에 의한 선언이 가장 대표적
	
SWITCH	
case ‘yellow’:	일단 케이스 조건 일치하면 그 이후 조건은 일치하지 않아도 모두 출력, 그래서 break 명령 사용
If → switch Conversion?	
	위에 삼항연산자도 조건문
for	for (var I = 0; I < 2; i++){
	
	var str = '';           // 숫자와 더해질 빈 문자열 선언 (빈문자열 선언은 그냥 '' single quotaion 두개로 가능)

# 05월 31일

## 알고리즘 10번
*이중 for* 문 사용해도 해결 가능
 
  for (var i = 0; i < 5; i++){  
    for (var j = 0; j <= i; j++){}  
  }  
 i : 0, j : 0  
 i : 1, j : 0~1  
 i : 2, j : 0~2  
  += '\n' 삽입할 수 있다  

**11번**도 이중 for문 사용해보자
  
>코드의 재사용성을 높이자 : ```효율성```, ```정확성```을 높이기 위함  
	
코드의 구조화를 위해서 프레임워크를 사용하자.  
JS에서는 함수안에서만 지역변수다. for문 안에 선언되어도 전역변수이다.  
for문을 돌릴 수 있는 다른 방법이 있다 (차주에 다룸)  
While은 무한 loop 필요 시 유용함 (게임 등)  
do while  
**continue** 짝수면 출력 안됨 (for 조건으로 다시 돌아감)  
**evaluating** 
평가의 결과물은 true/false  
```
if (x % 2)  : 짝수는 실행 안됨 값이 0이고 0은 false니까!!!  

ㅁ  
ㅁ  
```
**형변환**  
+문자열 / 문자열 * 1 : 숫자로 형 변환  
생성자 함수 : 객체를 생성  
Number(val) : number형 생성하는 함수  
val + "" : 문자열로 형 변환  

동등성 비교  

```==``` 와 ```===``` 의 차이 : ```===```는 타입까지 본다. ```==```는 가급적 true를 반환하려고 함!

**삼항연산자** : elem ? (true면 할일) : (false면 할일)  

```평가값을 갖는 객체는 그것이 false를 가졌더라도 해당 객체를 평가하게 되면 항상 true다!```  
식별은 Name, 데이터 접근/제어 key  


>object / function / type checking

prototype의 정의 (**hard**)

1. 객체(Object)
**객체** : 프로퍼티 + 메소드  
왼쪽(프로퍼티)이 이름 : 오른쪽이 프로퍼티의 값  
person object의 name property의 값은 lee  
프로퍼티의 값으로 함수(1급 객체)가 올 수 있다. 함수도 값이다.  
```프로퍼티의 값이 함수일 경우``` (객체의 프로퍼티이면)에 일반 함수와 구분하기 위해 **메소드**라 부른다.  
	프로토타입 기반 객체지향 언어 vs 클래스 기반 객체지향 언어
	syntactic sugar (클래스 기반 처럼 동작하는 자바스크립트, 기타 무엇무엇 처럼 동작하게끔 할때)
방식 3가지 (**차이점**)
	1. 객체 리터럴(값과 유사함/값이 될 수 있는 값을 이르는 게 리터럴)  
	함수 리터럴 : 함수 자체가 값이 될 수 있음을 내포하는 말  
	클래스의 목적은 인스턴스 생성  
	객체는 클래스가 필요가 없고 표현식만으로 객체를 생성할 수 있다.  

	2. object 생성자 함수 (*엔진이 사용하는 방식*)
	*cf.* 객체는 기본자료형이 아닌 것을 이를 때, **instance** 는 메모리에 올라간 객체의 실체를 이를 때 사용하는 용어  
	new : instance 생성 명령  
		함수안에는 구문이 모여 있으므로 이것이 실행된 결과 빈 객체 생성된다. 그 후에 프로퍼티 생성하자~  
	person.name 은 참조 (person객체의 name property), 할당 기호 들어가면 새로 프로퍼티를 생성하고 값을 할당한다.(동적 프로퍼티 할당)  
	동적 프로퍼티 할당 : 프로퍼티는 추후에도 언제든 할당 가능하다! (*클래스 기반 언어에서는 불가능한 행위*)  
	*생성자 함수가 존재하는 이유?* 객체 리터럴 방식은 syntactic sugar다! 1번 방식을 사용하면 2번으로 동작한다.

	3. 생성자 함수(대문자로 시작, 사용자간의 약속, **클래스 기반언어의 클래스와 생성자 함수**의 역할이 같다)  
	*동일한 형태의 객체를 다수 만들 때 사용하자*

	>```1번이 가장 많이 사용됨```

## **객체 프로퍼티 접근  **

**프로퍼티 이름** : 빈문자열을 포함한 문자 또는 숫자, 결국에는 문자열 화 됨  
프로퍼티에 따옴표를 생략할 수 있으나 **예외** first-name처럼 연산자 있을 때  

	cf. 변수명 생성 시  
	first-name 케밥 케이스 (X)  
	first_name snake case  
	firstName camel case  
	FirstNmae pascal case  

마침표 표기법 (일반적)  
대괄호 표기법 [first-name] 여기에는 ''생략하면 안 된다.  
person.1에서 1은 숫자로 인식됨.  

*cf.* delete는 안 쓰는게 좋음  
왜? 다른 사람이 사용할지도 모른다..  
객체 자체는 지울 수 없음 -> 메모리에서 우리가 직접 지울 수 없기 때문에  

## **pass-by-reference** (객체의 중요한 특징; *주소*를 넘겨 준다)
기본자료형은 *stack*에 값이 있다.  
객체는 프로그램이 돌 때(runtime일 때) 그 크기를 알 수 있다.  
기본자료형은 runtime 이전에 JS엔진이 데이터가 몇 킬로바이트 필요한지 알 수 있지만 (선언을 통해서 무조건 stack에 8바이트 할당 되기 때문에)  
*객체*는 동적으로 메모리가 조절 가능한 영역(HEAP)에 존재함 -> 프로퍼티 추가/삭제가 가능하기 때문에!  
*객체의 주소를 스택에 써둔다.*(엔진에 따라서 다를 수 있음) -> 주소는 바이트 수가 고정적.  
객체 자체에는 주소값이 저장되어 있다. (var bar = foo; foo객체의 메모리 주소가 bar 변수에 저장됨) 그래서 메모리 상에 **같은 실체**를 공유하게 됨 **var bar**와 **foo**가 같은 것을 참조한다 -> 따라서 *값의 변경은 모두에게 영향을 미칠 수 있다.*  
>pass by reference를 통해 메모리의 효율적 사용이 가능해 진다! (원론적 이유)
  
> ## ```pass by value vs pass by reference```  
> ## ```immutable vs mutable```

html도 객체로 관리되는데, 이 객체들을 관리하는 것이 DOM  

## **함수**
반복적으로 수행해야 한다면 구문의 집합을 정의 구문들의 집합을 **정의**하고 필요시에 **호출**하자.   (**코드의 *재사용*** 가능)

>일반적 기능(코드의 재사용) 이외에 객체 생성, 객체의 행위 지정(메소드), 정보의 구성 및 은닉, 클로저, 모듈화 등의 기능을 수행

함수 : 값으로 취급될 수 있다 (일급 객체이기 때문에.)	오브젝트 나라의 시민권자인 함수 ㅋㅋ

함수의 생성 방식
- 선언식
- 표현식
- function 생성자 함수 (by JS-engine)  

```함수 선언식  ```
	function(키워드) square(number) {
		return number * number;
	}
number는 지역변수인데 별도 선언 필요 없음 (var 필요 없음)

```익명 함수 표현식```
var square = function(number) {
  return number * number;
};  
함수가 값으로서 기능한다.  
함수객체의 주소를 square 변수에 저장  
**익명 함수표현식이 일반적**  
기명 함수표현식에서는 함수명 호출은 불가능

선언식 vs 표현식  
무엇을 써도 큰 상관 없음

선언식은, 함수표현식의 sytactic sugar, (여기서는 변수명이 square로 동작) 호이스팅 때문에 차이가 발생함

## **함수 호이스팅** 

변수 / 함수 호이스팅(사전적 정의 : 끌어올림)  
정확한 의미, 모든 선언문은 스코프의 최상단으로 옮겨진 것처럼 동작한다.  

- **변수 호이스팅** : *모든 선언문은 호이스팅 된다.* 프로그램 실행전에 js엔진이 코드를 전체적으로 읽어서 선언+초기화 단계를 거치고 이를 통해 메모리 크기를 추산한다. 그래서 아직 선언되지 않은 변수가 undefined 상태인 것이다! 이유는 '실행 컨텍스트'에서 다룬다.  
	

함수선언식은 함수 호이스팅 된다 : 선두에서 호출 **가능**  
함수표현식은 undefined 이기 때문에 선두에서 호출 **불가능** (undefined를 호출하는 꼴)  

first-class object(일급 객체)  
	함수가 왜 값으로 취급되는가? : 변수에 함수를 담을 수 있기 때문에 함수형 프로그래밍이 가능한 것임 -> 이것이 함수형 프로그래밍이라고 JS가 불리는 이유다.
	함수를 리턴할 수도 있음 	


>숙제  
```기술 부채 정리 시작```
1. 목록화 (keyword based)  
2. 최대한 이해한 바를 정리해 보자.  
3. 확인하자  












 






