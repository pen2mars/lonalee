#### 현재 웹 애플리케이션 구현 
>SPA (Single Page Application) 방식
#### JS 사용의 목적
>DOM(HTML, CSS)를 JS로 제어 
#### 비동기 통신 방식 
```
예를 들어보자. 
클릭버튼!
클릭이 언제 발생할지 알 수 없다! 
클릭이 발생하면 수행할 행위를 정해놓는다.(이 경우에는 eventlistner가 동작하면서 클릭 발생을 모니터링)
```
##### ECMA Script 버전 ES3/5/6
##### REACT는	LIBRARY에 가까움
##### ANGULAR :	FRAMEWORK는 애플리케이션 전체를 아우름
	
#### 초기 JS의 용도 
```
ID/PW 입력 여부 확인과 같은 행위를 하기 위해서 비전문가들도 쉽게 JS를 활용 가능하도록 만들어졌다. 
일반 애플리케이션은 OS에서 동작하도록 만들었으나 (설치 과정이 수반) 웹 애플리케이션은 그런 과정을 생략할 수 있다. 
그러면 웹 애플리케이션은 어떻게 동작시킬 것인가? 웹 브라우저에서 애플리케이션을 실행/제어하자 → JS 필요
초창기에는 PLAIN JS로 코딩하기가 어려웠음 → JQUERY 등장 → 그런데 JQUERY가 SPA에는 적합하지 않았음 
(JQUERY는 HTML에 의존적이기 때문에 사용을 지양하게 되었음) → ANGULAR, REACT, Vue.js의 사용이 대두
그러나, JS는 애플리케이션용 언어가 아니기 때문에 태생적 한계가 있다!
```
#### JS는 프로토타입 기반 객체지향 언어	
>클래스 vs 프로토타입    
#### Object 프로그래밍 하는 대상들을 각각 object로 인식 
>객체는 데이터와 행위를 포함한다 - 표현식으로 객체를 바로 생성 가능

#### 프로토타입의 정의?
>To be explained
	
#### JS	HTML, CSS를 JS로 동적으로 제어

#### 웹 브라우저의 동작 원리 (brief)
```파서``` : 텍스트를 파싱해서(txt-> byte code) 메모리에 저장 (line by line)  
**스크립트의 위치**는 *head*안이 아니고 **body**를 닫기 전에 위치 한다.  
```DOM(HTML요소)```를 제어하기 위해서는 바디 태그 맨 마지막에 있어야 한다.

#### 모듈화 미 지원	
```파일을 분리할 수 없음```  
여러 JS 파일 있어도 한개 파일만 동작. ES6에서 파일을 쪼개는 기능을 지원하나 현재 브라우저에서는 미지원.  
따라서 ```webpack```을 사용하여 이를 보완하고자 한다.
#### 브라우저 동작 원리	
DOM/CSSOM/syntax Tree는 메모리에 저장된다. HTML 1.1에서는 파일을 각각 요청해서 받음 (html, css, script 각각)  
**2.0은 다중 요청**이 가능하다고 한다.
#### 값 = literal	
숫자, 문자열(한개 이상의 문자 모두), boolean, undefined, null,symbol // 이상은 ```기본 자료형```  
_(**변수에 할당될** 바이트 수가 정해져 있다)_  
메모리 확보하는 방법이 다른 한 가지 // ```객체형```_(변수에 할당될 바이트수가 유동적)_  

#### Statement의 예를 보자
>var foo = 10;  
```선언문이자 할당문```  
var foo;  
```선언만 하고 할당 하지 않았다.``` 이러한 경우 **undefined**를 기본으로 갖게 됨
symbol은 ES6에서 추가됨  
표현식 정의  
```x + y 와 같이 특정 값을 갖게 될 수 있는 형식```

#### 코드블록으로 구문 그룹화
```
중괄호로 지정한 범위 구문은 세미콜론으로 닫는다. (optional)  
필요한 구문을 그룹화하여 추후 재사용 하도록 하자.  
```
#### scope	
변수의 범위 (유효범위-코드블럭)
#### control flow	
```
JS코딩에 익숙해지면 if/for는 지양해야 한다. 이유는 코드를 읽기가 어렵기 때문. 
그래서 고차함수를 사용함 (JS는 함수형 언어)
현재는 코드의 가독성을 높이는 것에 초점을 맞춘다. 코드의 효율성보다도 중요 
그래서 변수/함수 생성시 이름 중요(역할/용도 등의 힌트를 줄 수 있어야 한다.)
```
#### Expression(표현식)	
궁극적으로 하나의 값을 만드는 것  
#### 동적 typing  
var foo 에는 모든 형태의 변수가 다 들어올 수 있다  그래서 type을 지정하기 위해서 typescript 사용  
Var foo : string; (정적 typing)
# 변수 	
위치를 기억하는 저장소  
숫자표현은 8바이트가 할당된다.
메모리 참조 : 변수가 어디에 저장되었는지 찾자   
call by value 방식  
**STACK** : 정해진 크기의 메모리 할당 (기본자료형 할당되는 공간)  
**HEAP** : 유동적 크기의 메모리 할당 (객체형 할당)

*cf.* 문자열 1개는 2byte



	
```프로그래밍을 이해하기 위한``` _KEYWORDS  
>변수, 참조, 연산자, (데이터)흐름제어, 함수, 구문의 집합, 자료의 구조화

# 변수 (다시 한 번)
	변수는 주소를 식별할 수 있다.
	변수 할당 시 데이터의 크기 Var num(동적 타이핑) : 메모리의 일정 구역 확보 → undefined(변수선언 시 초기화 : 불필요한 더미값을 클리어 한다) → 값 할당 → 재할당할 경우 주소 변경되어 남게 된 기존 값은 불필요하기 때문에 garbage collection의 대상이 됨. (아무도 참조하지 않는 값) / garbage collection이 발생하는 시기는 알 수 없음
*cf.* 메모리의 이해  
#### 타입 추론
데이터형의 인지 : 값이 할당되는 과정에서 자동으로 변수의 자료형을 결정  
```기본자료형 vs 객체형```  
기본자료형 (primitive)은 변경불가능(immutable)한 값 (generally important in programming language)  
Pass by value
1. **boolean**	
2. **null** : 값이 없음을 명시하는 것 (참조 정보 제거 → garbage collection 대상이 됨) 굳이 null 변수 선언/할당할 필요는 없음
3. **undefined** : 변수 선언만 했을 때, 존재하지 않는 프로퍼티를 참조 시 undefined
4. **number** : JS에서는 숫자는 모두 실수 (*Infinity* : 2의 53승-1을 벗어나면 무한대 // *NaN* : 숫자를 문자로 나누는 등)
5. **string** : 여타 프로그래밍 언어에서는 string은 기본자료형이 아님
	
#### 객체형  
기본자료형과 반대되는 특징들이 많다. 크기가 정해지지 않는다!  
기본자료형은 stack에, 가변적인 객체형은 heap영역에서 관리됨   
`Mutable` 하다!  
	pass by reference :  
	**추상화** : 필요한 프로퍼티만 선언해서 객체를 표현한다. (프로퍼티와 행위로 객체를 구성)  
	**상속** : 다른 객체의 속성을 상속 받고 다른 속성도 사용할 수 있음  

**전역 변수** : 애플리케이션이 종료되지 않는 이상 계속 메모리 차지 (x=1처럼 var 키워드 생략 허용)  
**지역 변수** :	함수 내에게 선언된 변수  
**동적 타이핑** : 데이터 타입을 미리 선언하지 않는다. (값이 할당될 때 변수의 타입이 추론 될 것이다.)  
**정적 타이핑** : 미리 선언한다. (int n, char str 등등)
	
var 키워드로 선언된 변수의 문제점	다른 언어는 모든 코드 블럭이 유효범위(스코프) JS는 함수 범위만 유효
	대부분의 문제는 전역 변수로 인해 발생한다. 
연산자	
	숫자+문자할때는 자료형을 명시적으로 바꿔서 작업
'==’	사용 금지
html	자료를 받을 때는 모두 string (우리가 숫자를 입력하더라도..)
삼항연산자	활용도 높음  Condition ? ‘true’ : ‘false’;
	
var INPUT_ID_MIN_LEN = 5;	상수! (재할당하면 안됨 그러나 var는 강제할 방법 없음, 길고 자세한 대문자 변수명으로 의미만 부여하는 것임)
id.length	기본자료형(string)이었는데 이렇게 선언되면서 id가 객체로 취급된다
	
10+’10’ 10+10	OR조건으로 문자가 있으면 문자열 연결 연산자 AND조건으로 숫자가 있어야 산술 연산자
논리연산자	
var n3 = !'Cat';	 // false (문자열을 암묵적으로 형변환했다 -true)
	
단축평가	var foo = 'Cat' || 'Dog' (형변환 된 것이 넘어가는게 아니다!!!)
	Truthy / falsy
방어 코드 (미입력으로 인한 오류발생 방지)	function foo (str) {   str = str || '';   // do somethig with str   console.log(str.length); }  foo();     // 0 foo('hi'); // 2
빈 객체	truthy 밸류
!!	
자료형의 인식 	자료형의 인식을 통해서 오류 최소화, 인식이 안되면 강제로 형 변환 해야 함.
control flow	
for 문 중요	for문 대신 고차함수를 실무에서는 더 많이 사용함
블럭 구문	코드 블럭 (구문들의 집합체)   그룹화해서 재사용하려고 만든다
객체 만드는 3가지방법	객체리터럴에 의한 선언이 가장 대표적
	
SWITCH	
case ‘yellow’:	일단 케이스 조건 일치하면 그 이후 조건은 일치하지 않아도 모두 출력, 그래서 break 명령 사용
If → switch Conversion?	
	위에 삼항연산자도 조건문
for	for (var I = 0; I < 2; i++){
	
	var str = '';           // 숫자와 더해질 빈 문자열 선언 (빈문자열 선언은 그냥 '' single quotaion 두개로 가능)
