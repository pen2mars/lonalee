SPA	Single Page Application
DOM(HTML, CSS)를 JS로 제어
비동기 통신 방식	예) 클릭버튼 클릭이 언제 발생할지 알 수 없다! 눌려지면 이걸 해줘라고 행위를 정해놓는다(eventlistner)
ECMA Script 버전 ES3/5/6	
REACT는	LIBRARY에 가까움
ANGULAR :	FRAMEWORK는 애플리케이션 전체를 아우름
	
초기 js의 용도	EX. ID/PW 입력 여부 확인 비전문가들이 쉽게 활용 가능하도록 만들었다
어플리케이션은 os에서 동작하도록 만들었으나 (설치 과정이 수반) 웹 어플리케이션은 그런 과정을 생략할 수 있다 웹 브라우저에서 애플리케이션을 실행/제어하자 → JS의 활용
PLAIN JS로 코딩하기가 어려웠음 → JQUERY 등장 ->JQUERY가 SPA에는 적합하지 않았음 (JQUERY는 HTML에 의존적이기 때문에 사용을 지양하게 되었음)-> ANGULAR, REACT, Vue.js의 사용이 대두
JS는 애플리케이션용 언어가 아니기 때문에 태생적 한계가 있다
프로토타입 기반 객체지향 언어	클래스 vs 프로토타입    Object 프로그래밍 하는 대상들을 각각 object로 인식 (객체는 데이터와 행위를 포함한다 - 표현식으로 객체를 바로 생성 가능)

프로토타입의 정의?	
	
JS	HTML, CSS를 JS로 동적으로 제어
    관심사가 다르면 분리해라  업무 담당자가 다를 수 있기 때문에.
파서	텍스트를 파싱해서(txt-> byte code) 메모리에 저장 (line by line)
스크립트의 위치 → 헤드안이 아니고 바디태그 닫기 전에 위치 한다. DOM(HTML요소)를 제어하기 위해서는 바디 태그 맨 마지막에 있어야 한다.
모듈화 미 지원	
    파일을 분리할 수 없음(여러파일 있어도 한개 파일 동작). ES6에서 파일을 쪼개는 기능을 지원하나 브라우저는 미지원. 따라서 webpack 사용 
브라우저 동작 원리	
    DOM/CSSOM/syntax Tree는 메모리에 올라감 1.1은 파일을 각각 요청해서 받음 (html, css, script) 2.0은 다중 요청 가능
값 = literal	
숫자, 문자열(한개 이상의 문자 모두), boolean, undefined, null,symbol //기본 자료형(변수에 할당될 바이트 수가 정해져 있다) 
메모리 확보하는 방법이 다른 한 가지 //객체형(변수에 할당될 바이트수가 유동적)
var foo = 10;	선언문이며 할당문
var foo;	undefined를 기본으로 갖게 됨
symbol은 ES6에서 추가됨
표현식 정의	ex)x + y
구문 정의	
	
코드블록으로 구문 그룹화	
    중괄호로 지정한 범위 구문은 세미콜론으로 닫는다 (optional)  
    구문의 그룹화 → 추후 재사용 가능
scope	
    변수의 범위 (유효범위-코드블럭)
control flow	
    JS코딩에 익숙해지면 if/for는 지양해야 함   
    코드를 읽기가 어렵기 때문. (코드리뷰가 어려움) 
    그래서 고차함수를 사용함 (JS는 함수형 언어) 
    현재는 가독성 좋은 코드가 좋음 → 변수/함수 생성시 이름 중요(역할/용도 등의 힌트를 줄 수 있어야)
	
Expression	
    궁극적으로 하나의 값을 만드는 것
동적 typing	var foo 에는 모든 형태의 변수가 다 들어올 수 있다  그래서 type을 지정하기 위해서 typescript 사용 Var foo : string; (정적 typing)
변수 (제일 중요)	위치를 기억하는 저장소
숫자표현은 8바이트 할당된다.
메모리 참조 : 변수 찾기 위해서 
call by value	
STACK	정해진 크기의 메모리 할당(기본자료형 할당되는 공간)
HEAP	유동적 크기의 메모리 할당 영역 (객체형 할당)

문자열 1개는 2byte


주석	가독성을 높이기 위해서 잘 활용해야 함
	
프로그래밍	변수, 참조, 연산자, (데이터)흐름제어, 함수, 구문의 집합, 자료의 구조화
	
	변수는 주소를 식별할 수 있다
	변수 할당 시 데이터의 크기   Var num(동적 타이핑) : 메모리의 일정 구역 확보 → undefined(초기화:불필요한 더미값을 클리어한다, 변수 선언시) → 값 할당 → 재할당시 주소 변경되어 남게 된 기존 값은 불필요하기 때문에 garbage collection의 대상이 됨(아무도 참조하지 않는 값) / garbage collection이 발생하는 시기는 알 수 없음
메모리의 이해	
타입 추론	데이터형의 인지 :값이 할당되는 과정에서 자동으로 변수의 자료형 결정
기본자료형 vs 객체형	
기본자료형 (primitive)	변경불가능(immutable)한 값 (제너럴리 임포턴트 in programming language) Pass by value
1. boolean	
2. null	값이 없음을 명시하는 것 (참조정보 제거 → garbage collection 대상이 됨) 굳이 할 필요는 없음
3. undefined	존재하지 않는 프로퍼티를 참조 시 undefined
4. number	JS에서는 숫자는 모두 실수    Infinity : 2의 53승-1을 벗어나면 무한대   NaN : 숫자를 문자로 나누는 등
5. string	일반적으로 string은 기본자료형이 아님 (타 언어들은..)
	
객체형 기본자료형과 반대되는 특징들이 많음	크기가 정해지지 않는다! 기본자료형은 stack에, 가변적인 객체형은 heap영역에서 관리됨   Mutable
	pass by reference : 
	추상화  필요한 프로퍼티만 선언해서 객체를 표현한다. (프로퍼티와 행위로 객체를 구성)
	상속  다른 객체의 속성을 상속 받고 다른 속성도 사용
전역 변수	애플리케이션이 종료되지 않는 이상 계속 메모리 차지 (x=1 var 키워드 생략 허용)
지역 변수	함수 내에게 선언된 변수
동적 타이핑	데이터 타입을 미리 선언하지 않는다 (값이 할당될 때 변수의 타입이 추론 될 것이다)
정적 타이핑	미리 선언한다
	
var 키워드로 선언된 변수의 문제점	다른 언어는 모든 코드 블럭이 유효범위(스코프) JS는 함수 범위만 유효
	대부분의 문제는 전역 변수로 인해 발생한다. 
연산자	
	숫자+문자할때는 자료형을 명시적으로 바꿔서 작업
'==’	사용 금지
html	자료를 받을 때는 모두 string (우리가 숫자를 입력하더라도..)
삼항연산자	활용도 높음  Condition ? ‘true’ : ‘false’;
	
var INPUT_ID_MIN_LEN = 5;	상수! (재할당하면 안됨 그러나 var는 강제할 방법 없음, 길고 자세한 대문자 변수명으로 의미만 부여하는 것임)
id.length	기본자료형(string)이었는데 이렇게 선언되면서 id가 객체로 취급된다
	
10+’10’ 10+10	OR조건으로 문자가 있으면 문자열 연결 연산자 AND조건으로 숫자가 있어야 산술 연산자
논리연산자	
var n3 = !'Cat';	 // false (문자열을 암묵적으로 형변환했다 -true)
	
단축평가	var foo = 'Cat' || 'Dog' (형변환 된 것이 넘어가는게 아니다!!!)
	Truthy / falsy
방어 코드 (미입력으로 인한 오류발생 방지)	function foo (str) {   str = str || '';   // do somethig with str   console.log(str.length); }  foo();     // 0 foo('hi'); // 2
빈 객체	truthy 밸류
!!	
자료형의 인식 	자료형의 인식을 통해서 오류 최소화, 인식이 안되면 강제로 형 변환 해야 함.
control flow	
for 문 중요	for문 대신 고차함수를 실무에서는 더 많이 사용함
블럭 구문	코드 블럭 (구문들의 집합체)   그룹화해서 재사용하려고 만든다
객체 만드는 3가지방법	객체리터럴에 의한 선언이 가장 대표적
	
SWITCH	
case ‘yellow’:	일단 케이스 조건 일치하면 그 이후 조건은 일치하지 않아도 모두 출력, 그래서 break 명령 사용
If → switch Conversion?	
	위에 삼항연산자도 조건문
for	for (var I = 0; I < 2; i++){
	
	var str = '';           // 숫자와 더해질 빈 문자열 선언 (빈문자열 선언은 그냥 '' single quotaion 두개로 가능)
