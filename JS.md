#### 현재 웹 애플리케이션 구현 
>SPA (Single Page Application) 방식
#### JS 사용의 목적
>DOM(HTML, CSS)를 JS로 제어 
#### 비동기 통신 방식 
```
예를 들어보자. 
클릭버튼!
클릭이 언제 발생할지 알 수 없다! 
클릭이 발생하면 수행할 행위를 정해놓는다.(이 경우에는 eventlistner가 동작하면서 클릭 발생을 모니터링)
```
##### ECMA Script 버전 ES3/5/6
##### REACT는	LIBRARY에 가까움
##### ANGULAR :	FRAMEWORK는 애플리케이션 전체를 아우름
	
#### 초기 JS의 용도 
```
ID/PW 입력 여부 확인과 같은 행위를 하기 위해서 비전문가들도 쉽게 JS를 활용 가능하도록 만들어졌다. 
일반 애플리케이션은 OS에서 동작하도록 만들었으나 (설치 과정이 수반) 웹 애플리케이션은 그런 과정을 생략할 수 있다. 
그러면 웹 애플리케이션은 어떻게 동작시킬 것인가? 웹 브라우저에서 애플리케이션을 실행/제어하자 → JS 필요
초창기에는 PLAIN JS로 코딩하기가 어려웠음 → JQUERY 등장 → 그런데 JQUERY가 SPA에는 적합하지 않았음 
(JQUERY는 HTML에 의존적이기 때문에 사용을 지양하게 되었음) → ANGULAR, REACT, Vue.js의 사용이 대두
그러나, JS는 애플리케이션용 언어가 아니기 때문에 태생적 한계가 있다!
```
#### JS는 프로토타입 기반 객체지향 언어	
>클래스 vs 프로토타입    
#### Object 프로그래밍 하는 대상들을 각각 object로 인식 
>객체는 데이터와 행위를 포함한다 - 표현식으로 객체를 바로 생성 가능

#### 프로토타입의 정의?
>To be explained
	
#### JS	HTML, CSS를 JS로 동적으로 제어

#### 웹 브라우저의 동작 원리 (brief)
```파서``` : 텍스트를 파싱해서(txt-> byte code) 메모리에 저장 (line by line)  
**스크립트의 위치**는 *head*안이 아니고 **body**를 닫기 전에 위치 한다.  
```DOM(HTML요소)```를 제어하기 위해서는 바디 태그 맨 마지막에 있어야 한다.

#### 모듈화 미 지원	
```파일을 분리할 수 없음```  
여러 JS 파일 있어도 한개 파일만 동작. ES6에서 파일을 쪼개는 기능을 지원하나 현재 브라우저에서는 미지원.  
따라서 ```webpack```을 사용하여 이를 보완하고자 한다.
#### 브라우저 동작 원리	
DOM/CSSOM/syntax Tree는 메모리에 저장된다. HTML 1.1에서는 파일을 각각 요청해서 받음 (html, css, script 각각)  
**2.0은 다중 요청**이 가능하다고 한다.
#### 값 = literal	
숫자, 문자열(한개 이상의 문자 모두), boolean, undefined, null,symbol // 이상은 ```기본 자료형```  
_(**변수에 할당될** 바이트 수가 정해져 있다)_  
메모리 확보하는 방법이 다른 한 가지 // ```객체형```_(변수에 할당될 바이트수가 유동적)_  

#### Statement의 예를 보자
>var foo = 10;  
```선언문이자 할당문```  
var foo;  
```선언만 하고 할당 하지 않았다.``` 이러한 경우 **undefined**를 기본으로 갖게 됨
symbol은 ES6에서 추가됨  
표현식 정의  
```x + y 와 같이 특정 값을 갖게 될 수 있는 형식```

#### 코드블록으로 구문 그룹화
```
중괄호로 지정한 범위 구문은 세미콜론으로 닫는다. (optional)  
필요한 구문을 그룹화하여 추후 재사용 하도록 하자.  
```
#### scope	
변수의 범위 (유효범위-코드블럭)
#### control flow	
```
JS코딩에 익숙해지면 if/for는 지양해야 한다. 이유는 코드를 읽기가 어렵기 때문. 
그래서 고차함수를 사용함 (JS는 함수형 언어)
현재는 코드의 가독성을 높이는 것에 초점을 맞춘다. 코드의 효율성보다도 중요 
그래서 변수/함수 생성시 이름 중요(역할/용도 등의 힌트를 줄 수 있어야 한다.)
```
#### Expression(표현식)	
궁극적으로 하나의 값을 만드는 것  
#### 동적 typing  
var foo 에는 모든 형태의 변수가 다 들어올 수 있다  그래서 type을 지정하기 위해서 typescript 사용  
Var foo : string; (정적 typing)
# 변수 	
위치를 기억하는 저장소  
숫자표현은 8바이트가 할당된다.
메모리 참조 : 변수가 어디에 저장되었는지 찾자   
call by value 방식  
**STACK** : 정해진 크기의 메모리 할당 (기본자료형 할당되는 공간)  
**HEAP** : 유동적 크기의 메모리 할당 (객체형 할당)

*cf.* 문자열 1개는 2byte



	
```프로그래밍을 이해하기 위한``` _KEYWORDS  
>변수, 참조, 연산자, (데이터)흐름제어, 함수, 구문의 집합, 자료의 구조화

# 변수 (다시 한 번)
	변수는 주소를 식별할 수 있다.
	변수 할당 시 데이터의 크기 Var num(동적 타이핑) : 메모리의 일정 구역 확보 → undefined(변수선언 시 초기화 : 불필요한 더미값을 클리어 한다) → 값 할당 → 재할당할 경우 주소 변경되어 남게 된 기존 값은 불필요하기 때문에 garbage collection의 대상이 됨. (아무도 참조하지 않는 값) / garbage collection이 발생하는 시기는 알 수 없음
*cf.* 메모리의 이해  
#### 타입 추론
데이터형의 인지 : 값이 할당되는 과정에서 자동으로 변수의 자료형을 결정  
```기본자료형 vs 객체형```  
기본자료형 (primitive)은 변경불가능(immutable)한 값 (generally important in programming language)  
Pass by value
1. **boolean**	
2. **null** : 값이 없음을 명시하는 것 (참조 정보 제거 → garbage collection 대상이 됨) 굳이 null 변수 선언/할당할 필요는 없음
3. **undefined** : 변수 선언만 했을 때, 존재하지 않는 프로퍼티를 참조 시 undefined
4. **number** : JS에서는 숫자는 모두 실수 (*Infinity* : 2의 53승-1을 벗어나면 무한대 // *NaN* : 숫자를 문자로 나누는 등)
5. **string** : 여타 프로그래밍 언어에서는 string은 기본자료형이 아님
	
#### 객체형  
기본자료형과 반대되는 특징들이 많다. 크기가 정해지지 않는다!  
기본자료형은 stack에, 가변적인 객체형은 heap영역에서 관리됨   
`Mutable` 하다!  
	pass by reference :  
	**추상화** : 필요한 프로퍼티만 선언해서 객체를 표현한다. (프로퍼티와 행위로 객체를 구성)  
	**상속** : 다른 객체의 속성을 상속 받고 다른 속성도 사용할 수 있음  

**전역 변수** : 애플리케이션이 종료되지 않는 이상 계속 메모리 차지 (x=1처럼 var 키워드 생략 허용)  
**지역 변수** :	함수 내에게 선언된 변수  
**동적 타이핑** : 데이터 타입을 미리 선언하지 않는다. (값이 할당될 때 변수의 타입이 추론 될 것이다.)  
**정적 타이핑** : 미리 선언한다. (int n, char str 등등)
	
## var 키워드로 선언된 변수의 문제점	 
다른 언어는 모든 코드 블럭이 유효범위(스코프), *JS는 함수 범위만 유효*  
	대부분의 문제는 전역 변수로 인해 발생한다.  
연산자 사용 시, 숫자+문자할 때는 자료형을 명시적으로 바꿔서 작업  
'==’  *사용 금지*(true를 반환할 가능성 높음, 자료형에 대한 비교는 하지 않으므로..)  
html에서 사용자 입력과 같은 데이터를 받을 때는 모두 string으로 받음 (우리가 *숫자*를 입력하더라도..)  
**삼항연산자**	활용도 높음  (ex. Condition ? ‘true’ : ‘false’;)
	
```var INPUT_ID_MIN_LEN = 5;```	상수!  
(재할당하면 안됨. 그러나 var는 강제할 방법 없음, 길고 자세한 대문자 변수명으로 의미만 부여하는 것임)  
id.length	기본자료형(string)이었는데 이렇게 선언되면서 id가 객체로 취급된다  
	
```10+'10' 10+10```	OR조건으로 문자가 있으면 문자열 연결 연산자, AND조건으로 숫자가 있어야 산술 연산자
논리연산자  
var n3 = !'Cat'; // false (문자열을 암묵적으로 형변환했다 -true)
	
```단축평가```	
>var foo = 'Cat' || 'Dog' (형변환 된 것이 넘어가는게 아니다!!!)  

Truthy / falsy  

방어 코드 (미입력으로 인한 오류발생 방지)	  
	function foo (str)  
	{   str = str || '';   
	// do somethig with str   
	console.log(str.length); }  
	foo();     // 0  
	foo('hi'); // 2  

빈 객체 또한 truthy 밸류

자료형의 인식 	
자료형의 인식을 통해서 오류 최소화, 인식이 안되면 강제로 형 변환 해야 함.  
control flow	  
for 문 중요하지만	  
for문 대신 고차함수를 실무에서는 더 많이 사용함  
코드 블럭 (구문들의 집합체), 그룹화해서 재사용하려고 만든다  
	
SWITCH  
case ‘yellow’ : 일단 케이스 조건 일치하면 그 이후 조건은 일치하지 않아도 모두 출력, 그래서 break 명령 사용  
If → switch Conversion?  
위에 삼항연산자도 조건문  

# 05월 31일

## 알고리즘 10번
*이중 for* 문 사용해도 해결 가능
 
  for (var i = 0; i < 5; i++){  
    for (var j = 0; j <= i; j++){}  
  }  
 i : 0, j : 0  
 i : 1, j : 0~1  
 i : 2, j : 0~2  
  += '\n' 삽입할 수 있다  

**11번**도 이중 for문 사용해보자
  
>코드의 재사용성을 높이자 : ```효율성```, ```정확성```을 높이기 위함  
	
코드의 구조화를 위해서 프레임워크를 사용하자.  
JS에서는 변수가 함수 안에서만 지역변수다. for문 안에 선언되어도 전역변수이다.  
for문을 돌릴 수 있는 다른 방법(고차함수 사용)이 있다. (차주에 다룸)  
While은 무한 loop 필요 시 유용함 (게임 등)  
do while  
**continue** 짝수면 출력 안됨 (for 조건으로 다시 돌아감)  
**evaluating** 
평가의 결과물은 true/false  
```
if (x % 2)  : 짝수는 실행 안됨 값이 0이고 0은 false니까!!!  

ㅁ  
ㅁ  
```
**형변환**  
+문자열 / 문자열 * 1 : 숫자로 형 변환  
생성자 함수 : 객체를 생성  
Number(val) : number형 생성하는 함수  
val + "" : 문자열로 형 변환  

동등성 비교  

```==``` 와 ```===``` 의 차이 : ```===```는 타입까지 본다. ```==```는 가급적 true를 반환하려고 함!

**삼항연산자** : elem ? (true면 할일) : (false면 할일)  

```평가값을 갖는 객체는 그것이 false를 가졌더라도 해당 객체를 평가하게 되면 항상 true다!```  
식별은 Name, 데이터 접근/제어 key  


>object / function / type checking

prototype의 정의 (**hard**)

1. 객체(Object)
**객체** : 프로퍼티 + 메소드  (기본자료형(Primitives)을 제외한 나머지 값들(**함수, 배열, 정규표현식 등**)은 모두 객체)  
객체는 데이터를 한 곳에 모으고 구조화하는데 유용하다. 그래프나 트리와 같은 자료구조 표현 용이.  
- 왼쪽(프로퍼티)이 이름 : 오른쪽이 프로퍼티의 값  
person object의 name property의 값은 lee  
프로퍼티의 값으로 함수(1급 객체)가 올 수 있다. (함수도 값이다).  
```프로퍼티의 값이 함수일 경우``` (객체의 프로퍼티이면)에 일반 함수와 구분하기 위해 **메소드**라 부른다.  
	*cf.프로토타입 기반 객체지향 언어 vs 클래스 기반 객체지향 언어*  
	자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다.   
	하지만 자바스크립트는 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다.  
	*cf.syntactic sugar (클래스 기반 처럼 동작하는 자바스크립트, 기타 무엇무엇 처럼 동작하게끔 할때)*  

- 방식 3가지 (**차이점**)
	1. 객체 리터럴(**literal**? 값과 유사함/값이 될 수 있는 값을 이르는 말)  
	함수 리터럴 : 함수 자체가 값이 될 수 있음을 내포하는 말  
	클래스의 목적은 인스턴스 생성  
	객체는 클래스가 필요가 없고 표현식만으로 객체를 생성할 수 있다.  
	{} 내에 아무것도 기술하지 않으면 빈 객체  

	2. object 생성자 함수 (**엔진이 사용하는 방식**)  
	*cf.* 객체는 기본자료형이 아닌 것을 이를 때, **instance** 는 메모리에 올라간 객체의 실체를 이를 때 사용하는 용어  
	new : instance 생성 명령  
	object 생성자로 인해 빈 객체 생성된다. 그 후에 프로퍼티 생성하자~  
	동적 프로퍼티 할당 : 프로퍼티는 추후에도 언제든, 얼마든지 추가 할당 가능하다! (*클래스 기반 언어에서는 불가능한 행위*)  
	*생성자 함수가 존재하는 이유?* 객체 리터럴 방식은 syntactic sugar다! 1번 방식을 사용하면 내부적으로는 2번으로 동작한다.

	3. 생성자 함수(대문자로 시작, 사용자간의 약속, **클래스 기반언어의 클래스와 생성자 함수**의 역할이 같다)  
	*동일한 형태의 객체를 다수 만들 때 사용하자*
	this에 연결(바인딩)되어 있는 프로퍼티와 메소드는 public(외부에서 참조 가능)하다.  
	성자 함수 내에서 선언된 일반 변수는 private(외부에서 참조 불가능)하다.  

	>```1번이 가장 많이 사용됨```

## **객체 프로퍼티 접근**

**프로퍼티 이름** : 빈문자열을 포함한 문자 또는 숫자, 결국에는 이름 전체는 문자열로 간주됨.  
한 문자열 타입의 값으로 수렴될 수 있는 표현식도 가능.  
프로퍼티에 따옴표를 생략할 수 있으나 **예외** first-name처럼 연산자 있을 때  
JS의 예약어 또한 이름으로 사용하지는 말자.  

	cf. 변수명 생성 시  
	first-name : kebap case (X)  
	first_name : snake case  
	firstName : camel case  
	FirstNmae : pascal case  

마침표 표기법 (일반적)  
대괄호 표기법 [first-name] 여기에는 ''생략하면 안 된다.  
person.1에서 1은 숫자로 인식됨.  

*cf.* delete는 안 쓰는게 좋음  
왜? 다른 사람이 사용할지도 모른다..  
객체 자체는 지울 수 없음 -> 메모리에서 우리가 직접 지울 수 없기 때문에  

## **pass-by-reference** 
>(객체의 중요한 특징 -> *주소*를 넘겨 준다)  

기본자료형은 stack에 값이 있다. (pass-by-value : 값으로 전달된다-> 이 말은 **값이 복사되어 전달된다**는 의미!)  
객체는 프로그램이 돌 때(runtime일 때) 그 크기를 알 수 있다.  
기본자료형은 runtime 이전에 JS엔진이 메모리 크기가 얼마나 필요한지 알 수 있지만 (선언을 통해서 무조건 stack에 변수당 8바이트가 할당 되기 때문에.)  
*객체*는 동적으로 메모리가 조절 가능한 영역(HEAP)에 존재함 -> 프로퍼티 추가/삭제가 가능하기 때문에!  
*객체의 주소를 스택에 써둔다.*(엔진에 따라서 다를 수 있음) -> 주소는 바이트 수가 고정적.  
객체 자체에는 주소값이 저장되어 있다. (var bar = foo; foo객체의 메모리 주소가 bar 변수에 저장됨) 그래서 메모리 상에 **같은 실체**를 공유하게 됨 **varbar**와 **foo**가 같은 것을 참조한다 -> 따라서 *값의 변경은 모두에게 영향을 미칠 수 있다.*  
>pass by reference를 통해 메모리의 효율적 사용이 가능해 진다! (원론적 이유)  
  
> ## ```pass by value vs pass by reference```  
> ## ```immutable vs mutable```

### *tip.*  
	객체의 프로퍼티 값을 기본자료형 변수에 할당하고 그 객체의 프로퍼티 값을 변경하면 변수의 값은 변경되지 않는다.  
	이는 변수에 프로퍼티 값을 할당했을 때 그 참조를 할당하는 것이 아니라 immutable한 값이 메모리에 새로 생성되고 변수는 이것을 참조하기 때문이다.  
	따라서 프로퍼티의 값이 변경된다 하더라도 변수가 참조하고 있는 값은 변함이 없다.  
	어떤 객체를 새로운 객체 변수에 할당(참조값을 전달한다!)하면, 프로퍼티 값 변경은 두 객체 모두에 영향을 미친다.  



html도 객체로 관리되는데, 이 객체들을 관리하는 것이 DOM  

## **함수**
반복적으로 수행해야 한다면 구문의 집합을 정의 구문들의 집합을 **정의**하고 필요시에 **호출**하자.   (**코드의 *재사용*** 가능)

>일반적 기능(코드의 재사용) 이외에 객체 생성, 객체의 행위 지정(메소드), 정보의 구성 및 은닉, 클로저, 모듈화 등의 기능을 수행  
함수는 구문(statement)의 집합으로 모듈화의 근간이 된다.  
**일반적인 프로그래밍 기술**이란? "*요구사항*" -> "*자료구조 + 함수*"의 집합으로 변환  

함수 : 값으로 취급될 수 있다 (일급 객체이기 때문에.)	오브젝트 나라의 시민권자인 함수 ㅋㅋ  
즉 변수나 객체, 배열 등에 저장할 수 있고 다른 함수에 전달되는 인수로도 사용할 수 있으며 함수의 반환값이 될 수도 있다.  

## **함수의 생성 방식**
- 선언식
- 표현식
- function 생성자 함수 (by JS-engine)

```함수 선언식```  
	function(키워드) square(number) {  
		return number * number;  
	}  
number는 지역변수인데 별도 선언 필요 없음 (var 필요 없음)  

```익명 함수 표현식```
var square = function(number) {  
  return number * number;  
};  
함수가 값으로서 기능한다.  
함수객체의 주소를 square 변수에 저장  
**익명 함수표현식이 일반적**  
기명 함수표현식에서는 함수명 호출은 불가능

선언식 vs 표현식  
무엇을 써도 큰 상관 없음

선언식은, 함수표현식의 sytactic sugar, (여기서는 변수명이 square로 동작) 호이스팅 때문에 차이가 발생함

## **함수 호이스팅** 

변수 / 함수 호이스팅(사전적 정의 : 끌어올림)  
정확한 의미, 모든 선언문은 스코프의 최상단으로 옮겨진 것처럼 동작한다.  

- **변수 호이스팅** : *모든 선언문은 호이스팅 된다.* 프로그램 실행전에 js엔진이 코드를 전체적으로 읽어서 선언+초기화 단계를 거치고(Variable Object에 저장, 할당은 따로 발생함) 이를 통해 메모리 크기를 추산한다. 그래서 아직 선언되지 않은 변수가 undefined 상태인 것이다! 이유는 '실행 컨텍스트'에서 다룬다.  
	

	>함수선언식은 함수 호이스팅 된다 : 선두에서 호출 **가능**  
	함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능
	함수표현식은 undefined 이기 때문에 선두에서 호출 **불가능** (undefined를 호출하는 꼴)  
	>함수표현식의 경우 함수 호이스팅이 아니라 **변수 호이스팅**이 발생한다. 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행


**first-class object(일급 객체)**  
정의 : 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 *제한없이 사용*할 수 있는 대상
	함수가 왜 값으로 취급되는가? : 변수에 함수를 담을 수 있기 때문에 함수형 프로그래밍이 가능한 것임 -> 이것이 함수형 프로그래밍이라고 JS가 불리는 이유다.
	함수를 리턴할 수도 있음 	

3. 함수의 파라미터로 전달 할 수 있다 ~

>숙제  
```기술 부채 정리 시작```
1. 목록화 (keyword based)  
2. 최대한 이해한 바를 정리해 보자.  
3. 확인하자  

# 6월 4일

함수객체의 프로퍼티
	arguments 프로퍼티 : 유사 배열 객체
	arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다.
	유사배열객체란 length 프로퍼티를 가진 객체
	배열 메소드를 사용하는 경우 에러가 발생하게 된다. 따라서 배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용하여야 하는 번거로움이 있다.

length 프로퍼티 : 매개변수의 갯수
arguments.length와는 다를 수 있다.(호출 시 인자의 갯수)

매개변수 (Parameter, 인자) : 매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당

모든 객체는  [[prototype]] 숨겨진 프로퍼티를 갖는다. [[prototype]]은 underscore proto underscore와 같다
	[[prototype]]은 자신의 부모역할을 하는 객체(프로토타입 객체)를 가리킨다.
	함수의 프로토타입 객체는 Function.prototype (이것도 함수)
함수 객체는 prototype 프로퍼티를 갖는다

console.dir(square.__proto__); // [Function]
console.dir(square.prototype); // square {}
console.dir(Function.prototype); // [Function]
console.dir(square); // [Function: square]

>cf. javascripttutorial.net
	function Foo(name) {  
    this.name = name;  
}  

Foo 함수는 인자를 받아들여서 네임 프로퍼티를 객체에 생성하고 네임 프로퍼티의 값을 인자값으로 설정한다.
내부적으로는, JS 엔진이 새로운 함수 Foo와 무명의 객체를 생성한다. Foo함수는 prototype이라는 프로퍼티를 갖게 된다. 이 prototype은 생성된 무명의 객체를 가리키고 있다. 그리고 무명 객체는 constructor라는 프로퍼티가 Foo 함수를 가리키게 한다.
추가적으로, Foo.prototype 객체는 [[prototype]]을 통해서 Object.prototype 객체에 연결되어 있다. [[prototype]]은 prototype linkage이다.




상속을 위해서 프로토타입(부모 객체)이 존재함
객체지향 언어가 되기 위해서 중요한 속성은 '상속' : 부모것(프로퍼티)을 자식이 언제든 사용할 수 있다.

모든 객체가 소유하고 있는 숨겨진 프로퍼티 __proto__   
부모역할을 하는 객체를 가리키고 있다.  
함수객체만 가지는 프로토타입 = prototype  
생성된 객체의 입장에서는 '__proto__' 로 참조  
생성자함수 입장에서는 prototype으로 참조  

IIFE 
선언과 동시에 호출 (한번만 호출 가능)
초기화 처리에 사용
호출 -> () 사용

자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도 글로벌 스코프가 하나(전역이 1개다)이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것이다. 모듈화 미지원(JS의 가장 큰 단점)

스코프 : JS는 함수 내부만 스코프로 인정됨  
함수 동작 완료 후 (return undefined도 포함)  
```전역 변수 사용을 지양하기 위해서 IIFE를 사용하는 것!```

내부 함수 (클로저와 연관됨?)
지역변수는 함수 스코프 안에서만 유효함

## 콜백 함수
특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다.  
비동기 처리에 사용된다.  (사용빈도 매우 높음 99.9%)  

프로토타입 객체 : 모든 객체가 갖는 **부모 역할을 하는** 객체 (부모객체와 링크되어 있다 - 상속 개념과 유사)
*cf. 프로토타입 프로퍼티*

var student = {
  name: 'Lee',
  score: 90
};

// student에는 hasOwnProperty 메소드가 없지만 아래 구문은 동작한다.
console.log(student.hasOwnProperty('name')); // true
	hasOwnProperty 메소드 : 부모역할을 하는 프로토타입 객체가 갖고 있다.
console.dir(student);
	객체 내부를 보면 __proto__를 통해 프로토타입 객체의 메소드들을 볼 수 있다

student.__proto__ === Object.prototype (**실체**와 링크되어 있다) 	//true

일반함수도 프로토타입(이라는 프로퍼티)을 갖고 있지만 무의미하다. (왜 갖고 있나, 생성자함수(new와 함께 동작)도 일반함수에 포함되는 것, 생성자함수로 쓸 때 프로토타입이 의미를 갖는다, 생성자 함수는 대문자 사용으로 명시하자)

프로토타입 체인 : 프로토타입 객체만 따라 올라갈 수 있다.
object.prototype : 프로토타입 체인의 종점 (여기에도 없으면 reference error)


객체 리터럴에 메소드가 포함되어 있다 : 

var person = {  
  name: 'Lee',  
  gender: 'male',  
  sayHello: function(){  
    console.log('Hi! my name is ' + this.name);  
  }  
};  

person 객체는 object 생성자 함수에 의해  

생성자 함수 사용 시 : 생성자함수.prototype에 동일한 기능을 하는 메소드를 포함시키면 
효율적으로 메모리를 사용가능 (프로토타입 체인에 의해서 자식 객체들이 참조해서 사용할 수 있다)  **그림 참조**

constructor 프로퍼티 는 프로토타입 객체가 갖고 있음(생성자 함수를 가리킨다)
foo.constructor 로 생성자 함수를 찾아갈 수 있다 (프로토타입 체인이 사용 됨, foo에는 constructor 프로퍼티가 없기 때문에 Person.prototype에서 찾는다)
 
Person.prototype.sayHello = function(){  
  console.log('Hi! my name is ' + this.name);  
};  
>생성자함수.prototype에 함수를 추가하자  

wrapper 함수? : 

'.' 사용하면 기본자료을 객체화화
var str = 'test';
console.log(typeof str);                 // string
console.log(str.constructor === String-생성자함수); // true
console.dir(str);         

string객체의 프로토타입 객체에 메소드 추가는 가능하나 하면 안됨

Native object : 사용환경에 영향 받지 않는 코어 영역
Host object : ECMA script spec에 없음

예 : node.JS 같은 환경에서 사용할 수 있냐 없냐

네이티브 객체 

object가 인수를 무엇으로 받는지에 따라서 어떤 객체를 만들지 결정

JS에서 에러처리 방법
	JS에는 비동기 처리방식이 많은데, 이 때 에러처리가 안된다. 

'.'가 나오면 래퍼객체가 기본자료형을 객체로 바꿔준다.

호스트 객체 (현재까지는 native객체를 배우는 중이었음)
환경에 영향을 받는 객체, 표준에 포함되지 않음

전역 객체
애플리케이션 전역에서 참조 가능한 객체
예) 브라우저 시작 시 window라는 객체가 존재하기 시작, 사용자가 만드는 변수,객체(함수도 포함) 등이 window에 포함됨


var ga = 'Global variable';  
console.log(ga);  
console.log(window.ga);  
 
전역변수는 윈도우 객체의 자식, 전역함수도 윈도우 객체의 자식  

eval() : 사용금지

메소드이름의 패턴이 있다

전역객체에 있는 메소드는 형변환 후에 결과 산출

number, matn객체는 형변환 하지 않는다. (isNaN 관련)

### parseInt()
문자열을 숫자 형으로 바꿀 때 사용	

encodeURI / decodeURI
### URI : 
fragment 내부 이동,페이지 전환 없는 요청

## BOM (스스로 학습하자)

# DOM (중요)
웹 문서를 컨트롤 한다.

메소드 학습 방법
	메소드명(keyword) 와 친숙해지자 : 어떤 메소드가 있는지 알고
	실제 적용시에 사용법을 익혀 나가자
	ex. string객체의 메소드를 이론 설명 -> 문제를 풀 떄 메소드 적용을 고민해라

6/4

























